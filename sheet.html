
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AuraSheet V2.0</title>
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <!-- Phosphor Icons for modern UI look -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');

        /* --- THEME CONFIGURATION --- */
        :root {
            /* Light Mode Variables */
            --bg-gradient: radial-gradient(at 0% 0%, hsla(253,16%,7%,1) 0, transparent 50%), 
                           radial-gradient(at 50% 0%, hsla(225,39%,30%,1) 0, transparent 50%), 
                           radial-gradient(at 100% 0%, hsla(339,49%,30%,1) 0, transparent 50%);
            --bg-color: #eef2f9;
            --blob-1: #62a1ff;
            --blob-2: #ff94c2;
            --blob-3: #a8edea;

            --glass-surface: rgba(255, 255, 255, 0.65);
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            
            --text-main: #2d3748;
            --text-muted: #718096;
            --primary-accent: #3182ce;
            
            --grid-line: rgba(0, 0, 0, 0.08);
            --header-bg: rgba(255, 255, 255, 0.85);
            --header-text: #4a5568;
            
            --selection-border: #3182ce;
            --selection-bg: rgba(49, 130, 206, 0.15);
        }

        body.dark-mode {
            /* Dark Mode Variables */
            --bg-color: #0f172a;
            --blob-1: #4c1d95;
            --blob-2: #be185d;
            --blob-3: #1e40af;

            --glass-surface: rgba(30, 41, 59, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);

            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --primary-accent: #60a5fa;

            --grid-line: rgba(255, 255, 255, 0.08);
            --header-bg: rgba(15, 23, 42, 0.85);
            --header-text: #cbd5e1;

            --selection-border: #60a5fa;
            --selection-bg: rgba(96, 165, 250, 0.2);
        }

        /* --- GLOBAL STYLES --- */
        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-main);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: color 0.3s ease, background-color 0.3s ease;
        }

        /* Ambient Background Blobs */
        .background-blobs {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
        }
        .blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.6;
            animation: float 20s infinite alternate;
        }
        .blob-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--blob-1); animation-delay: 0s; }
        .blob-2 { bottom: -10%; right: -10%; width: 40vw; height: 40vw; background: var(--blob-2); animation-delay: -5s; }
        .blob-3 { top: 40%; left: 40%; width: 30vw; height: 30vw; background: var(--blob-3); animation-delay: -10s; }

        @keyframes float {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(20px, 40px) scale(1.1); }
        }

        /* --- GLASS MIXIN CLASSES --- */
        .glass-panel {
            background: var(--glass-surface);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
        }

        /* --- TOOLBAR --- */
        #toolbar {
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            z-index: 50;
            border-bottom: 1px solid var(--glass-border);
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding-right: 16px;
            border-right: 1px solid var(--glass-border);
        }
        .toolbar-group:last-of-type { border-right: none; }

        button {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-main);
            padding: 6px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; /* Icon size */
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--primary-accent);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        button:active { transform: translateY(0); }

        /* Text Buttons */
        .text-btn {
            font-size: 13px;
            font-weight: 500;
            padding: 6px 12px;
        }

        /* Inputs */
        input[type="color"] {
            border: none;
            width: 24px;
            height: 24px;
            padding: 0;
            background: none;
            cursor: pointer;
        }

        /* Theme Toggle */
        #theme-toggle {
            margin-left: auto;
            color: var(--text-muted);
        }
        #theme-toggle:hover { color: var(--text-main); }

        /* --- FORMULA BAR --- */
        #formula-bar {
            display: flex;
            align-items: center;
            padding: 8px 20px;
            gap: 10px;
            z-index: 40;
        }

        #current-cell-label {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 13px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.05);
            border-radius: 6px;
            min-width: 45px;
            text-align: center;
            color: var(--primary-accent);
            border: 1px solid var(--glass-border);
        }

        #formula-input {
            flex-grow: 1;
            padding: 8px 12px;
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            background: rgba(0,0,0,0.05);
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            outline: none;
            transition: all 0.2s;
        }
        #formula-input:focus {
            background: rgba(0,0,0,0.1);
            border-color: var(--primary-accent);
            box-shadow: 0 0 0 2px var(--selection-bg);
        }

        /* --- GRID CONTAINER --- */
        #grid-wrapper {
            flex-grow: 1;
            margin: 10px 20px 20px 20px;
            border-radius: 12px;
            overflow: hidden; /* For border radius */
            border: 1px solid var(--glass-border);
            background: var(--glass-surface);
            backdrop-filter: blur(12px);
            box-shadow: var(--glass-shadow);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #grid-container {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--text-muted) transparent;
        }
        
        #grid-container::-webkit-scrollbar { width: 10px; height: 10px; }
        #grid-container::-webkit-scrollbar-track { background: transparent; }
        #grid-container::-webkit-scrollbar-thumb { 
            background: rgba(128,128,128,0.3); 
            border-radius: 5px; 
            border: 2px solid transparent; 
            background-clip: content-box; 
        }
        #grid-container::-webkit-scrollbar-thumb:hover { background-color: rgba(128,128,128,0.5); }

        /* --- TABLE STYLES --- */
        #spreadsheet {
            border-collapse: collapse;
            table-layout: fixed;
            /* Removes spacing between cells */
        }

        #sizer {
            position: absolute;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* Headers (Sticky) */
        #spreadsheet th, #spreadsheet td {
            height: 28px;
            padding: 0 6px;
            box-sizing: border-box;
            border: 1px solid var(--grid-line);
            white-space: nowrap;
            overflow: hidden;
            font-size: 13px;
            cursor: default;
        }

        #spreadsheet th {
            background: var(--header-bg); /* Opaque enough to hide scrolling content */
            backdrop-filter: blur(10px);
            color: var(--header-text);
            font-weight: 600;
            text-align: center;
            position: sticky;
            z-index: 10;
            user-select: none;
        }
        
        /* Row Headers (1, 2, 3...) */
        #spreadsheet td:first-child {
            background: var(--header-bg);
            backdrop-filter: blur(10px);
            color: var(--header-text);
            font-weight: 500;
            text-align: center;
            border-right: 2px solid var(--glass-border);
            position: sticky;
            left: 0;
            z-index: 10;
        }

        /* The corner piece */
        #spreadsheet th:first-child {
            z-index: 20 !important;
            border-right: 2px solid var(--glass-border);
            background: var(--header-bg);
        }

        /* Cells */
        .cell {
            background: transparent; 
            color: var(--text-main);
            outline: none;
        }

        .cell.selected {
            border: 2px solid var(--selection-border) !important;
            background-color: var(--selection-bg);
            z-index: 5;
            position: relative;
        }

        .cell.editing {
            background-color: var(--bg-color); /* Solid bg when editing for readability */
            color: var(--text-main);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 6;
            cursor: text;
        }

        .cell-error {
            color: #ef4444; /* Red */
            font-weight: bold;
        }
        
        /* Tooltip style for hints */
        [title]:hover::after {
            content: attr(title);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }

    </style>
</head>
<body>

<!-- Ambient Background -->
<div class="background-blobs">
    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>
    <div class="blob blob-3"></div>
</div>

<input type="file" id="file-input" style="display: none;" accept=".csv, .xlsx">

<!-- Toolbar -->
<div id="toolbar" class="glass-panel">
    <div class="toolbar-group">
        <button id="open-file-btn" class="text-btn"><i class="ph ph-folder-open" style="margin-right:5px;"></i> Open</button>
        <button id="download-xlsx" class="text-btn" style="color: #107c41;"><i class="ph ph-file-xls" style="margin-right:5px;"></i> XLSX</button>
        <button id="download-csv" class="text-btn" style="color: #805ad5;"><i class="ph ph-file-csv" style="margin-right:5px;"></i> CSV</button>
    </div>
    <div class="toolbar-group">
        <button id="bold-btn"><i class="ph ph-text-b"></i></button>
        <button id="italic-btn"><i class="ph ph-text-italic"></i></button>
        <button id="underline-btn"><i class="ph ph-text-underline"></i></button>
    </div>
    <div class="toolbar-group">
        <button id="align-left-btn"><i class="ph ph-text-align-left"></i></button>
        <button id="align-center-btn"><i class="ph ph-text-align-center"></i></button>
        <button id="align-right-btn"><i class="ph ph-text-align-right"></i></button>
    </div>
    <div class="toolbar-group" style="font-size: 13px; font-weight: 500;">
        <div style="display: flex; align-items: center; gap: 5px;">
            <i class="ph ph-text-t"></i>
            <input type="color" id="font-color-picker" value="#000000">
        </div>
        <div style="display: flex; align-items: center; gap: 5px; margin-left: 8px;">
            <i class="ph ph-paint-bucket"></i>
            <input type="color" id="bg-color-picker" value="#ffffff">
        </div>
    </div>
    <div class="toolbar-group">
        <button id="add-row-btn" class="text-btn"><i class="ph ph-plus"></i> Row</button>
        <button id="add-col-btn" class="text-btn"><i class="ph ph-plus"></i> Col</button>
        <button id="clear-all-btn" class="text-btn" style="color: #ef4444;"><i class="ph ph-trash"></i></button>
    </div>
    
    <button id="theme-toggle" title="Toggle Dark Mode">
        <i class="ph ph-moon"></i>
    </button>
</div>

<!-- Formula Bar -->
<div id="formula-bar" class="glass-panel" style="border-top: none;">
    <div id="current-cell-label">A1</div>
    <i class="ph ph-function" style="color: var(--text-muted);"></i>
    <input type="text" id="formula-input" placeholder="Enter value or =SUM(A1:B2)...">
</div>

<!-- Main Grid Wrapper -->
<div id="grid-wrapper">
    <div id="grid-container">
        <div id="sizer"></div>
        <table id="spreadsheet"></table>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    let numRows = 100;
    let numCols = 26;
    const ROW_HEIGHT = 28; 
    const COL_WIDTH = 100; 
    const HEADER_HEIGHT = 29; 
    const ROW_HEADER_WIDTH = 50; 
    const BUFFER = 5; 
    const STORAGE_KEY = 'spreadsheet_data_v3';
    const THEME_KEY = 'glass_sheet_theme';

    // --- STATE ---
    let sheetData = {};
    let columnHeaders = [];
    let selectedCellId = 'A1';
    let dependencies = {};
    let dependents = {};
    
    // --- DOM ELEMENTS ---
    let gridContainer, sizer, spreadsheet, formulaInput, currentCellLabel;

    // --- UTILITY ---
    function colIndexToLetter(col) { 
        let s = ''; 
        while (col >= 0) { 
            s = String.fromCharCode(col % 26 + 65) + s; 
            col = Math.floor(col / 26) - 1; 
        } 
        return s; 
    }
    
    function cellIdToIndices(id) { 
        if (!id) return null; 
        const m = id.match(/^([A-Z]+)(\d+)$/i); 
        if (!m) return null; 
        let c = 0; 
        for (let i = 0; i < m[1].length; i++) { 
            c = c * 26 + m[1].charCodeAt(i) - 64; 
        } 
        return { row: parseInt(m[2]) - 1, col: c - 1 }; 
    }
    
    function indicesToCellId(r, c) { 
        return `${colIndexToLetter(c)}${r + 1}`; 
    }

    // --- THEME LOGIC ---
    function initTheme() {
        const savedTheme = localStorage.getItem(THEME_KEY);
        const toggleBtn = document.getElementById('theme-toggle');
        const icon = toggleBtn.querySelector('i');
        
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-mode');
            icon.classList.replace('ph-moon', 'ph-sun');
        }

        toggleBtn.onclick = () => {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
            
            if (isDark) icon.classList.replace('ph-moon', 'ph-sun');
            else icon.classList.replace('ph-sun', 'ph-moon');
        };
    }

    // --- DATA PERSISTENCE ---
    function saveToLocalStorage() {
        try {
            const dataToSave = { numRows, numCols, sheetData, columnHeaders };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        } catch (e) { console.error("Failed to save:", e); }
    }

    function loadFromLocalStorage() {
        const savedData = localStorage.getItem(STORAGE_KEY);
        if (savedData) {
            try {
                const parsedData = JSON.parse(savedData);
                numRows = parsedData.numRows || 100;
                numCols = parsedData.numCols || 26;
                sheetData = parsedData.sheetData || {};
                columnHeaders = parsedData.columnHeaders || [];
            } catch (e) { console.error("Failed to load:", e); }
        }
    }

    // --- VIRTUALIZATION ENGINE ---
    function renderVisibleGrid() {
        const totalHeight = numRows * ROW_HEIGHT + HEADER_HEIGHT;
        const totalWidth = numCols * COL_WIDTH + ROW_HEADER_WIDTH;
        sizer.style.height = `${totalHeight}px`;
        sizer.style.width = `${totalWidth}px`;

        const { scrollTop, scrollLeft, clientWidth, clientHeight } = gridContainer;
        
        const firstRow = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER);
        const lastRow = Math.min(numRows, Math.ceil((scrollTop + clientHeight) / ROW_HEIGHT) + BUFFER);
        const firstCol = Math.max(0, Math.floor(scrollLeft / COL_WIDTH) - BUFFER);
        const lastCol = Math.min(numCols, Math.ceil((scrollLeft + clientWidth) / COL_WIDTH) + BUFFER);

        spreadsheet.innerHTML = '';
        const frag = document.createDocumentFragment();

        // --- HEADER ROW ---
        const trHeader = document.createElement('tr');
        
        const thCorner = document.createElement('th');
        thCorner.style.minWidth = `${ROW_HEADER_WIDTH}px`;
        thCorner.style.position = 'sticky';
        thCorner.style.left = '0';
        thCorner.style.top = '0';
        thCorner.innerHTML = '<i class="ph ph-corners-out"></i>';
        trHeader.appendChild(thCorner);

        if (firstCol > 0) {
            const thSpacer = document.createElement('th');
            thSpacer.style.minWidth = `${firstCol * COL_WIDTH}px`;
            thSpacer.style.padding = '0';
            thSpacer.style.border = 'none';
            thSpacer.style.background = 'transparent'; 
            trHeader.appendChild(thSpacer);
        }

        for (let j = firstCol; j < lastCol; j++) {
            const th = document.createElement('th');
            th.textContent = columnHeaders[j] || colIndexToLetter(j);
            th.dataset.col = j;
            th.style.minWidth = `${COL_WIDTH}px`;
            th.style.position = 'sticky';
            th.style.top = '0';
            trHeader.appendChild(th);
        }
        frag.appendChild(trHeader);

        // --- VERTICAL SPACER ---
        if (firstRow > 0) {
            const trSpacer = document.createElement('tr');
            trSpacer.style.height = `${firstRow * ROW_HEIGHT}px`;
            const tdSpacer = document.createElement('td');
            tdSpacer.colSpan = (lastCol - firstCol) + 2; 
            tdSpacer.style.padding = '0';
            tdSpacer.style.border = 'none';
            trSpacer.appendChild(tdSpacer);
            frag.appendChild(trSpacer);
        }

        // --- DATA ROWS ---
        for (let i = firstRow; i < lastRow; i++) {
            const tr = document.createElement('tr');
            
            // Row Header
            const rh = document.createElement('td');
            rh.textContent = i + 1;
            rh.style.minWidth = `${ROW_HEADER_WIDTH}px`;
            tr.appendChild(rh);

            // Horizontal Spacer
            if (firstCol > 0) {
                const tdSpacer = document.createElement('td');
                tdSpacer.style.minWidth = `${firstCol * COL_WIDTH}px`;
                tdSpacer.style.padding = '0';
                tdSpacer.style.border = 'none';
                tr.appendChild(tdSpacer);
            }

            // Cells
            for (let j = firstCol; j < lastCol; j++) {
                const td = document.createElement('td');
                const id = indicesToCellId(i, j);
                td.id = id;
                td.classList.add('cell');
                if (id === selectedCellId) td.classList.add('selected');
                
                const data = sheetData[id];
                const value = data ? data.value : '';
                td.textContent = value !== undefined ? value : '';
                
                if (typeof value === 'string' && value.startsWith('#')) td.classList.add('cell-error');
                if (data && data.style) Object.assign(td.style, data.style);

                tr.appendChild(td);
            }
            frag.appendChild(tr);
        }

        spreadsheet.appendChild(frag);
    }

    // --- LOGIC & FORMULAS ---
    function adjustFormulas(type, insertIndex, amount) {
        Object.keys(sheetData).forEach(id => {
            const data = sheetData[id];
            if (data && data.formula) {
                data.formula = data.formula.replace(/\b([A-Z]+[0-9]+)(:[A-Z]+[0-9]+)?\b/g, (match, startRef, rangePart) => {
                    const endRef = rangePart ? rangePart.substring(1) : null;
                    const updateRef = (ref) => {
                        const indices = cellIdToIndices(ref);
                        if (!indices) return ref;
                        if (type === 'row' && indices.row >= insertIndex) indices.row += amount;
                        else if (type === 'col' && indices.col >= insertIndex) indices.col += amount;
                        return indicesToCellId(indices.row, indices.col);
                    };
                    const newStartRef = updateRef(startRef);
                    return endRef ? `${newStartRef}:${updateRef(endRef)}` : newStartRef;
                });
            }
        });
    }

    function addRow() {
        if (!selectedCellId) return;
        const { row: selectedRow } = cellIdToIndices(selectedCellId);
        const insertIndex = selectedRow + 1;
        numRows++;
        
        const newSheetData = { ...sheetData };
        const sortedKeys = Object.keys(sheetData).filter(k => cellIdToIndices(k).row >= insertIndex)
            .sort((a,b) => cellIdToIndices(b).row - cellIdToIndices(a).row);

        sortedKeys.forEach(oldId => {
            const {row, col} = cellIdToIndices(oldId);
            const newId = indicesToCellId(row + 1, col);
            newSheetData[newId] = newSheetData[oldId];
            delete newSheetData[oldId];
        });
        sheetData = newSheetData;
        
        adjustFormulas('row', insertIndex, 1);
        buildDependencyGraph();
        recalculateSheet();
        saveToLocalStorage();
    }

    function addColumn() {
        if (!selectedCellId) return;
        const { col: selectedCol } = cellIdToIndices(selectedCellId);
        const insertIndex = selectedCol + 1;
        numCols++;
        
        const newSheetData = { ...sheetData };
        const sortedKeys = Object.keys(sheetData).filter(k => cellIdToIndices(k).col >= insertIndex)
            .sort((a,b) => cellIdToIndices(b).col - cellIdToIndices(a).col);

        sortedKeys.forEach(oldId => {
            const {row, col} = cellIdToIndices(oldId);
            const newId = indicesToCellId(row, col + 1);
            newSheetData[newId] = newSheetData[oldId];
            delete newSheetData[oldId];
        });
        sheetData = newSheetData;

        adjustFormulas('col', insertIndex, 1);
        columnHeaders.splice(insertIndex, 0, undefined);
        buildDependencyGraph();
        recalculateSheet();
        saveToLocalStorage();
    }

    // --- DEPENDENCIES ---
    function updateDependencies(id, formula) {
        (dependencies[id] || []).forEach(depId => {
            dependents[depId] = (dependents[depId] || []).filter(d => d !== id);
        });
        dependencies[id] = [];
        if (formula && formula.startsWith('=')) {
            const cellRefs = formula.match(/[A-Z]+[0-9]+/gi) || [];
            const uniqueRefs = [...new Set(cellRefs.map(ref => ref.toUpperCase()))];
            dependencies[id] = uniqueRefs;
            uniqueRefs.forEach(refId => {
                if (!dependents[refId]) dependents[refId] = [];
                if (!dependents[refId].includes(id)) dependents[refId].push(id);
            });
        }
    }

    function buildDependencyGraph() {
        dependencies = {}; dependents = {};
        Object.keys(sheetData).forEach(id => {
            if (sheetData[id]?.formula) updateDependencies(id, sheetData[id].formula);
        });
    }

    // --- CALCULATOR ---
    const formulaFunctions = {
        SUM: args => args.flat().map(v => parseFloat(v)).filter(v => !isNaN(v)).reduce((a, b) => a + b, 0),
        AVERAGE: args => { const n = args.flat().map(parseFloat).filter(v => !isNaN(v)); return n.length ? n.reduce((a, b) => a + b, 0) / n.length : 0; },
        COUNT: args => args.flat().filter(v => v !== null && v !== '').length,
        MIN: args => Math.min(...args.flat().map(parseFloat).filter(v => !isNaN(v))),
        MAX: args => Math.max(...args.flat().map(parseFloat).filter(v => !isNaN(v))),
        PRODUCT: args => args.flat().map(v => parseFloat(v)).filter(v => !isNaN(v)).reduce((a, b) => a * b, 1),
        IF: (args) => {
             let cond; try { cond = new Function(`return ${args[0]}`)(); } catch(e) { cond = args[0]; }
             return (cond === true || cond === "true" || parseFloat(cond) > 0) ? args[1] : args[2];
        },
        CONCAT: args => args.flat().join(''),
        VLOOKUP: (args) => {
            const val = args[0], arr = args[1], col = parseInt(args[2]) - 1;
            if(!Array.isArray(arr)) return '#N/A';
            const row = arr.find(r => String(r[0]) === String(val));
            return row ? (row[col] ?? '') : '#N/A';
        }
    };

    function getCellValue(ref, visited) {
        if (!/^[A-Z]+[0-9]+$/i.test(ref)) return ref;
        const id = ref.toUpperCase();
        if (visited.has(id)) return '#REF!';
        visited.add(id);
        const data = sheetData[id];
        let val = data ? (data.formula ? evaluateFormula(data.formula, new Set(visited)) : data.value) : undefined;
        visited.delete(id);
        const num = parseFloat(val);
        return !isNaN(num) && String(val).trim() !== '' ? num : val;
    }

    function getRangeValues(startId, endId, visited) {
        const s = cellIdToIndices(startId);
        const e = cellIdToIndices(endId);
        if (!s || !e) return [];
        const vals = [];
        for (let r = Math.min(s.row, e.row); r <= Math.max(s.row, e.row); r++) {
            const row = [];
            for (let c = Math.min(s.col, e.col); c <= Math.max(s.col, e.col); c++) {
                row.push(getCellValue(indicesToCellId(r, c), visited));
            }
            vals.push(row);
        }
        return vals;
    }

    function evaluateFormula(formula, visited = new Set()) {
        try {
            if (!window.math) return "Loading...";
            let expr = formula.substring(1);
            const scope = {};
            const allRefs = expr.match(/[A-Z]+[0-9]+(:[A-Z]+[0-9]+)?/gi) || [];
            
            [...new Set(allRefs)].forEach(ref => {
                if (visited.has(ref)) throw new Error('#REF!');
                let val;
                if (ref.includes(':')) {
                    const [s, e] = ref.split(':');
                    val = getRangeValues(s, e, new Set(visited));
                } else {
                    val = getCellValue(ref, new Set(visited));
                }
                const scopeVar = ref.replace(':', '_');
                scope[scopeVar] = val;
                expr = expr.replaceAll(ref, scopeVar);
            });

            Object.keys(formulaFunctions).forEach(fn => {
                scope[fn] = (...args) => formulaFunctions[fn](args);
            });

            const result = math.evaluate(expr, scope);
            return result === Infinity ? '#DIV/0!' : result;
        } catch (e) { return '#ERROR!'; }
    }

    function recalculateSheet() {
        Object.keys(sheetData).forEach(id => {
            if (sheetData[id]?.formula) sheetData[id].value = evaluateFormula(sheetData[id].formula);
        });
        renderVisibleGrid();
    }

    function recalculate(startId) {
        const queue = [startId], visited = new Set([startId]);
        while (queue.length) {
            const curr = queue.shift();
            const data = sheetData[curr];
            if (data?.formula) data.value = evaluateFormula(data.formula);
            const cell = document.getElementById(curr);
            if (cell) {
                cell.textContent = data.value !== undefined ? data.value : '';
                if (String(data.value).startsWith('#')) cell.classList.add('cell-error');
                else cell.classList.remove('cell-error');
            }
            (dependents[curr] || []).forEach(d => {
                if (!visited.has(d)) { queue.push(d); visited.add(d); }
            });
        }
    }

    // --- INTERACTION ---
    function updateCell(id, input) {
        if (!id) return;
        if (!sheetData[id]) sheetData[id] = {};
        const data = sheetData[id];
        const oldFormula = data.formula;
        const isFormula = typeof input === 'string' && input.startsWith('=');
        
        if (isFormula) { data.formula = input; delete data.value; }
        else { delete data.formula; data.value = input; }
        
        if (oldFormula !== (isFormula ? input : null)) updateDependencies(id, isFormula ? input : null);
        recalculate(id);
        saveToLocalStorage();
    }

    function selectCell(cellOrId) {
        const newId = typeof cellOrId === 'string' ? cellOrId : cellOrId.id;
        if (!newId) return;
        
        if (selectedCellId) {
            const prev = document.getElementById(selectedCellId);
            if (prev) prev.classList.remove('selected');
        }
        selectedCellId = newId;
        
        const {row, col} = cellIdToIndices(newId);
        const top = row * ROW_HEIGHT;
        const left = col * COL_WIDTH;
        const {scrollTop, scrollLeft, clientHeight, clientWidth} = gridContainer;
        
        if (top < scrollTop) gridContainer.scrollTop = top;
        else if (top > scrollTop + clientHeight - ROW_HEIGHT) gridContainer.scrollTop = top - clientHeight + ROW_HEIGHT + HEADER_HEIGHT;
        
        if (left < scrollLeft) gridContainer.scrollLeft = left;
        else if (left > scrollLeft + clientWidth - COL_WIDTH) gridContainer.scrollLeft = left - clientWidth + COL_WIDTH + ROW_HEADER_WIDTH;

        renderVisibleGrid(); 
        
        const next = document.getElementById(newId);
        if(next) next.classList.add('selected');
        
        currentCellLabel.textContent = newId;
        const data = sheetData[newId];
        formulaInput.value = data ? (data.formula || data.value || '') : '';
    }

    function makeCellEditable(cell, clear) {
        if (!cell || cell.classList.contains('editing')) return;
        cell.classList.add('editing');
        cell.contentEditable = true;
        const data = sheetData[cell.id];
        cell.textContent = clear ? '' : (data ? (data.formula || data.value || '') : '');
        cell.focus();
        
        const finish = () => {
            cell.contentEditable = false;
            cell.classList.remove('editing');
            updateCell(cell.id, cell.textContent);
            selectCell(cell);
            cell.removeEventListener('blur', finish);
            cell.removeEventListener('keydown', onKey);
        };
        const onKey = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finish(); }
            if (e.key === 'Escape') { cell.textContent = data ? (data.value || '') : ''; finish(); }
        };
        cell.addEventListener('blur', finish);
        cell.addEventListener('keydown', onKey);
    }

    function handleFile(e) {
        const f = e.target.files[0];
        if(!f) return;
        if(!confirm("Overwrite current sheet?")) return;
        const r = new FileReader();
        r.onload = (evt) => {
            try {
                const wb = XLSX.read(new Uint8Array(evt.target.result), {type:'array'});
                const ws = wb.Sheets[wb.SheetNames[0]];
                const json = XLSX.utils.sheet_to_json(ws, {header:1});
                
                sheetData = {}; columnHeaders = []; dependencies = {}; dependents = {};
                numRows = Math.max(100, json.length + 20);
                numCols = Math.max(26, (json[0]?.length || 0) + 5);
                
                json.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if(val != null) {
                            const id = indicesToCellId(r, c);
                            sheetData[id] = {};
                            if(String(val).startsWith('=')) sheetData[id].formula = val;
                            else sheetData[id].value = val;
                        }
                    });
                });
                buildDependencyGraph();
                recalculateSheet();
                saveToLocalStorage();
                selectCell('A1');
            } catch(err) { alert("Error reading file"); console.error(err); }
        };
        r.readAsArrayBuffer(f);
        e.target.value = '';
    }

    function downloadCSV() {
        let maxR = -1, maxC = -1;
        Object.keys(sheetData).forEach(k => {
            const {row, col} = cellIdToIndices(k);
            if(row > maxR) maxR = row;
            if(col > maxC) maxC = col;
        });
        if(maxR === -1) return alert("Sheet empty");
        
        const rows = [];
        for(let r=0; r<=maxR; r++) {
            const row = [];
            for(let c=0; c<=maxC; c++) {
                const v = String(sheetData[indicesToCellId(r,c)]?.value ?? '');
                row.push(v.includes(',') ? `"${v}"` : v);
            }
            rows.push(row.join(','));
        }
        const blob = new Blob([rows.join('\n')], {type:'text/csv'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'document.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    function downloadXLSX() {
        let maxR = -1, maxC = -1;
        Object.keys(sheetData).forEach(k => {
            const {row, col} = cellIdToIndices(k);
            if(row > maxR) maxR = row;
            if(col > maxC) maxC = col;
        });
        if(maxR === -1) return alert("Sheet is empty");

        let html = '<table><tbody>';
        const hasCustomHeaders = columnHeaders.some(h => h !== undefined);

        if (hasCustomHeaders) {
            html += '<tr>';
            for (let c = 0; c <= maxC; c++) {
                let headerText = columnHeaders[c] || ""; 
                html += `<th>${headerText}</th>`;
            }
            html += '</tr>';
        }

        for(let r=0; r<=maxR; r++) {
            html += '<tr>';
            for(let c=0; c<=maxC; c++) {
                const id = indicesToCellId(r, c);
                const cell = sheetData[id];
                const value = cell ? (cell.value !== undefined ? cell.value : '') : '';
                
                let styleStr = '';
                if (cell && cell.style) {
                    styleStr = Object.entries(cell.style)
                        .map(([k, v]) => `${k.replace(/[A-Z]/g, m => '-' + m.toLowerCase())}:${v}`)
                        .join(';');
                }
                
                html += `<td style="${styleStr}">${value}</td>`;
            }
            html += '</tr>';
        }
        html += '</tbody></table>';

        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const table = doc.querySelector('table');
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.table_to_sheet(table);
            XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
            XLSX.writeFile(wb, "document.xlsx");
        } catch(e) {
            console.error(e);
            alert("Error converting to XLSX");
        }
    }

    // --- INIT ---
    document.addEventListener('DOMContentLoaded', () => {
        gridContainer = document.getElementById('grid-container');
        sizer = document.getElementById('sizer');
        spreadsheet = document.getElementById('spreadsheet');
        formulaInput = document.getElementById('formula-input');
        currentCellLabel = document.getElementById('current-cell-label');

        initTheme();
        loadFromLocalStorage();
        buildDependencyGraph();
        recalculateSheet();
        selectCell('A1');

        gridContainer.addEventListener('scroll', () => requestAnimationFrame(renderVisibleGrid));
        
        spreadsheet.addEventListener('click', e => {
            const cell = e.target.closest('.cell');
            if(cell) {
                if(cell.id !== selectedCellId) selectCell(cell);
                makeCellEditable(cell, false);
            }
        });
        
        spreadsheet.addEventListener('dblclick', e => {
            const th = e.target.closest('th[data-col]');
            if(th) {
                const col = parseInt(th.dataset.col);
                const old = th.textContent;
                th.contentEditable = true; th.focus();
                const end = () => {
                    th.contentEditable = false;
                    const val = th.textContent.trim();
                    if(val && val !== old) columnHeaders[col] = val;
                    else delete columnHeaders[col];
                    th.textContent = columnHeaders[col] || colIndexToLetter(col);
                    saveToLocalStorage();
                    th.removeEventListener('blur', end);
                };
                th.addEventListener('blur', end);
                th.addEventListener('keydown', e => { if(e.key === 'Enter') { e.preventDefault(); end(); }});
            }
        });

        formulaInput.addEventListener('change', e => updateCell(selectedCellId, e.target.value));
        formulaInput.addEventListener('keydown', e => { if(e.key==='Enter') { updateCell(selectedCellId, e.target.value); document.activeElement.blur(); }});

        window.addEventListener('keydown', e => {
            if(document.querySelector('.cell.editing')) return;
            if(!selectedCellId || (document.activeElement && !['BODY','TABLE','DIV'].includes(document.activeElement.tagName))) return;
            
            const {row, col} = cellIdToIndices(selectedCellId);
            if(e.key.length === 1 && !e.ctrlKey && !e.metaKey) { e.preventDefault(); makeCellEditable(document.getElementById(selectedCellId), true); }
            else if(e.key === 'F2' || e.key === 'Enter') { e.preventDefault(); makeCellEditable(document.getElementById(selectedCellId), false); }
            else if(e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); updateCell(selectedCellId, ''); }
            else if(e.key === 'ArrowUp') selectCell(indicesToCellId(Math.max(0, row-1), col));
            else if(e.key === 'ArrowDown') selectCell(indicesToCellId(Math.min(numRows-1, row+1), col));
            else if(e.key === 'ArrowLeft') selectCell(indicesToCellId(row, Math.max(0, col-1)));
            else if(e.key === 'ArrowRight') selectCell(indicesToCellId(row, Math.min(numCols-1, col+1)));
        });

        // Toolbar Events
        const click = (id, fn) => {
            const el = document.getElementById(id);
            if(el) el.onclick = fn;
        };
        
        const apply = (s, v) => { 
            if(!selectedCellId) return; 
            sheetData[selectedCellId] = sheetData[selectedCellId] || {}; 
            sheetData[selectedCellId].style = sheetData[selectedCellId].style || {};
            sheetData[selectedCellId].style[s] = v;
            const cell = document.getElementById(selectedCellId);
            if(cell) Object.assign(cell.style, sheetData[selectedCellId].style);
            saveToLocalStorage();
        };

        click('bold-btn', () => apply('fontWeight', 'bold'));
        click('italic-btn', () => apply('fontStyle', 'italic'));
        click('underline-btn', () => apply('textDecoration', 'underline'));
        click('align-left-btn', () => apply('textAlign', 'left'));
        click('align-center-btn', () => apply('textAlign', 'center'));
        click('align-right-btn', () => apply('textAlign', 'right'));
        click('add-row-btn', addRow);
        click('add-col-btn', addColumn);
        click('clear-all-btn', () => { if(confirm("Clear all data?")) { localStorage.removeItem(STORAGE_KEY); location.reload(); }});
        click('download-csv', downloadCSV);
        click('download-xlsx', downloadXLSX);
        click('open-file-btn', () => document.getElementById('file-input').click());
        document.getElementById('file-input').onchange = handleFile;
        document.getElementById('font-color-picker').oninput = e => apply('color', e.target.value);
        document.getElementById('bg-color-picker').oninput = e => apply('backgroundColor', e.target.value);
    });
</script>
</body>
</html>
