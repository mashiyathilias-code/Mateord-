<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Spreadsheet Engine (XLSX Enabled)</title>
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Fira+Code&display=swap');

        :root {
            --primary-color: #0078d4;
            --primary-color-light: #eff6fc;
            --primary-color-focus: rgba(0, 120, 212, 0.25);
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #6c757d;
            --text-color: #212529;
            --border-color: #ced4da;
            --error-color: #d13438;
            --excel-green: #107c41;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f5f5f5;
            color: var(--text-color);
            overflow: hidden;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            padding: 8px 16px;
            background-color: #ffffff;
            border-bottom: 1px solid var(--medium-gray);
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
            z-index: 30;
        }
        .toolbar-group {
            display: flex;
            align-items: center;
            border-right: 1px solid var(--medium-gray);
            padding-right: 12px;
        }
        .toolbar-group:last-child { border-right: none; }
        
        #toolbar button {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid transparent;
            background: transparent;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        #toolbar button:hover { background-color: var(--light-gray); color: var(--primary-color); }
        
        /* Specific button styles */
        #download-xlsx { color: var(--excel-green); font-weight: 600; }
        #download-xlsx:hover { background-color: #e6f2ea; }
        #download-csv { color: purple; font-weight: 600}

        /* Icons for alignment */
        .icon-btn::before {
            content: ''; display: inline-block; width: 16px; height: 16px;
            background-color: currentColor;
            -webkit-mask-size: contain; mask-size: contain;
            -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat;
            -webkit-mask-position: center; mask-position: center;
        }
        #align-left-btn::before { -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath d='M2 3h12v2H2V3zm0 4h8v2H2V7zm0 4h12v2H2v-2z'/%3E%3C/svg%3E"); mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath d='M2 3h12v2H2V3zm0 4h8v2H2V7zm0 4h12v2H2v-2z'/%3E%3C/svg%3E"); }
        #align-center-btn::before { -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath d='M2 3h12v2H2V3zm2 4h8v2H4V7zm-2 4h12v2H2v-2z'/%3E%3C/svg%3E"); mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath d='M2 3h12v2H2V3zm2 4h8v2H4V7zm-2 4h12v2H2v-2z'/%3E%3C/svg%3E"); }
        #align-right-btn::before { -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath d='M2 3h12v2H2V3zm4 4h8v2H6V7zm-4 4h12v2H2v-2z'/%3E%3C/svg%3E"); mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath d='M2 3h12v2H2V3zm4 4h8v2H6V7zm-4 4h12v2H2v-2z'/%3E%3C/svg%3E"); }

        /* --- FORMULA BAR --- */
        #formula-bar {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background-color: #fff;
            border-bottom: 1px solid var(--medium-gray);
        }
        #current-cell-label {
            font-weight: 600; padding: 6px 12px;
            background-color: var(--light-gray);
            border: 1px solid var(--border-color);
            border-right: none; border-radius: 4px 0 0 4px;
            font-family: 'Fira Code', monospace;
            min-width: 40px; text-align: center;
        }
        #formula-input {
            flex-grow: 1; padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 0 4px 4px 0;
            outline: none;
            font-family: 'Fira Code', monospace;
        }
        #formula-input:focus { border-color: var(--primary-color); }

        /* --- GRID CONTAINER (Virtualization) --- */
        #grid-container {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            background-color: #fff;
        }
        #sizer {
            position: absolute;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        #spreadsheet {
            position: absolute;
            top: 0; left: 0;
            border-collapse: collapse;
            table-layout: fixed;
        }

        /* --- CELLS & HEADERS --- */
        #spreadsheet th, #spreadsheet td {
            border: 1px solid var(--medium-gray);
            padding: 0 4px;
            height: 28px; /* Must match JS ROW_HEIGHT */
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            font-size: 13px;
            cursor: default;
        }

        /* Headers */
        #spreadsheet th {
            background-color: var(--light-gray);
            font-weight: 600;
            text-align: center;
            user-select: none;
        }
        
        /* Cells */
        .cell {
            background-color: #fff;
            outline: none;
        }
        .cell.selected {
            border: 2px solid var(--primary-color);
            background-color: rgba(0, 120, 212, 0.05);
            z-index: 5; /* Show border above neighbors */
            position: relative;
        }
        .cell.editing {
            background-color: #fff;
            cursor: text;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 6;
            overflow: visible;
        }
        .cell-error { color: var(--error-color); font-weight: bold; }

        /* Custom Scrollbar */
        #grid-container::-webkit-scrollbar { width: 14px; height: 14px; }
        #grid-container::-webkit-scrollbar-track { background: #f1f1f1; }
        #grid-container::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 7px; border: 3px solid #f1f1f1; }
        #grid-container::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        
        /* Corner Button */
        #spreadsheet th:first-child {
            z-index: 20 !important; /* Always on top */
        }
    </style>
</head>
<body>

<input type="file" id="file-input" style="display: none;" accept=".csv, .xlsx">
  
<div id="toolbar">
    <div class="toolbar-group">
        <button id="open-file-btn">Open</button>
        <button id="download-csv">Download CSV (Uses less storage)</button>
        <!-- Modified Button -->
        <button id="download-xlsx">Download XLSX (More supported)</button>
    </div>
    <div class="toolbar-group">
        <button id="bold-btn"><b>B</b></button>
        <button id="italic-btn"><i>I</i></button>
        <button id="underline-btn"><u>U</u></button>
    </div>
    <div class="toolbar-group">
        <button id="align-left-btn" class="icon-btn" title="Align Left"></button>
        <button id="align-center-btn" class="icon-btn" title="Align Center"></button>
        <button id="align-right-btn" class="icon-btn" title="Align Right"></button>
    </div>
    <div class="toolbar-group">
        <label for="font-color-picker" style="font-size:12px;">Text:</label>
        <input type="color" id="font-color-picker" value="#000000">
        <label for="bg-color-picker" style="font-size:12px; margin-left:5px;">Fill:</label>
        <input type="color" id="bg-color-picker" value="#ffffff">
    </div>
    <div class="toolbar-group">
        <button id="add-row-btn">Add Row</button>
        <button id="add-col-btn"> Add Col</button>
        <button id="clear-all-btn" style="color: #d13438;">Clear</button>
    </div>
</div>
  
<div id="formula-bar">
    <div id="current-cell-label">A1</div>
    <input type="text" id="formula-input">
</div>

<!-- Grid Container -->
<div id="grid-container">
    <div id="sizer"></div>
    <table id="spreadsheet"></table>
</div>

<script>
    // --- CONFIGURATION ---
    let numRows = 100;
    let numCols = 26;
    const ROW_HEIGHT = 28; 
    const COL_WIDTH = 100; 
    const HEADER_HEIGHT = 29; 
    const ROW_HEADER_WIDTH = 50; 
    const BUFFER = 5; 
    const STORAGE_KEY = 'spreadsheet_data_v3';

    // --- STATE ---
    let sheetData = {};
    let columnHeaders = [];
    let selectedCellId = 'A1';
    let dependencies = {};
    let dependents = {};
    
    // --- DOM ELEMENTS ---
    let gridContainer, sizer, spreadsheet, formulaInput, currentCellLabel;

    // --- UTILITY ---
    function colIndexToLetter(col) { 
        let s = ''; 
        while (col >= 0) { 
            s = String.fromCharCode(col % 26 + 65) + s; 
            col = Math.floor(col / 26) - 1; 
        } 
        return s; 
    }
    
    function cellIdToIndices(id) { 
        if (!id) return null; 
        const m = id.match(/^([A-Z]+)(\d+)$/i); 
        if (!m) return null; 
        let c = 0; 
        for (let i = 0; i < m[1].length; i++) { 
            c = c * 26 + m[1].charCodeAt(i) - 64; 
        } 
        return { row: parseInt(m[2]) - 1, col: c - 1 }; 
    }
    
    function indicesToCellId(r, c) { 
        return `${colIndexToLetter(c)}${r + 1}`; 
    }

    // --- DATA PERSISTENCE ---
    function saveToLocalStorage() {
        try {
            const dataToSave = { numRows, numCols, sheetData, columnHeaders };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        } catch (e) { console.error("Failed to save:", e); }
    }

    function loadFromLocalStorage() {
        const savedData = localStorage.getItem(STORAGE_KEY);
        if (savedData) {
            try {
                const parsedData = JSON.parse(savedData);
                numRows = parsedData.numRows || 100;
                numCols = parsedData.numCols || 26;
                sheetData = parsedData.sheetData || {};
                columnHeaders = parsedData.columnHeaders || [];
            } catch (e) { console.error("Failed to load:", e); }
        }
    }

    // --- VIRTUALIZATION ENGINE (With Sticky Headers) ---
    function renderVisibleGrid() {
        // 1. Set Scrollable Area Size
        const totalHeight = numRows * ROW_HEIGHT + HEADER_HEIGHT;
        const totalWidth = numCols * COL_WIDTH + ROW_HEADER_WIDTH;
        sizer.style.height = `${totalHeight}px`;
        sizer.style.width = `${totalWidth}px`;

        // 2. Get Viewport Info
        const { scrollTop, scrollLeft, clientWidth, clientHeight } = gridContainer;
        
        const firstRow = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER);
        const lastRow = Math.min(numRows, Math.ceil((scrollTop + clientHeight) / ROW_HEIGHT) + BUFFER);
        const firstCol = Math.max(0, Math.floor(scrollLeft / COL_WIDTH) - BUFFER);
        const lastCol = Math.min(numCols, Math.ceil((scrollLeft + clientWidth) / COL_WIDTH) + BUFFER);

        // 3. Clear Table
        spreadsheet.innerHTML = '';
        const frag = document.createDocumentFragment();

        // --- RENDER HEADER ROW (Freeze Panes: Top) ---
        const trHeader = document.createElement('tr');
        
        // A. Corner Cell (Sticky Top & Left)
        const thCorner = document.createElement('th');
        thCorner.style.minWidth = `${ROW_HEADER_WIDTH}px`;
        thCorner.style.position = 'sticky';
        thCorner.style.left = '0';
        thCorner.style.top = '0';
        thCorner.style.zIndex = '20'; // Highest priority
        thCorner.style.backgroundColor = '#f8f9fa';
        thCorner.style.borderRight = '2px solid #dee2e6';
        trHeader.appendChild(thCorner);

        // B. Spacer for scrolled-away left columns
        if (firstCol > 0) {
            const thSpacer = document.createElement('th');
            thSpacer.style.minWidth = `${firstCol * COL_WIDTH}px`;
            thSpacer.style.padding = '0';
            thSpacer.style.border = 'none';
            trHeader.appendChild(thSpacer);
        }

        // C. Visible Column Headers
        for (let j = firstCol; j < lastCol; j++) {
            const th = document.createElement('th');
            th.textContent = columnHeaders[j] || colIndexToLetter(j);
            th.dataset.col = j;
            // Force Sticky Top
            th.style.minWidth = `${COL_WIDTH}px`;
            th.style.position = 'sticky';
            th.style.top = '0';
            th.style.zIndex = '10';
            trHeader.appendChild(th);
        }
        frag.appendChild(trHeader);

        // --- VERTICAL SPACER (Pushes rows down) ---
        if (firstRow > 0) {
            const trSpacer = document.createElement('tr');
            trSpacer.style.height = `${firstRow * ROW_HEIGHT}px`;
            const tdSpacer = document.createElement('td');
            tdSpacer.colSpan = (lastCol - firstCol) + 2; 
            tdSpacer.style.padding = '0';
            tdSpacer.style.border = 'none';
            trSpacer.appendChild(tdSpacer);
            frag.appendChild(trSpacer);
        }

        // --- RENDER DATA ROWS ---
        for (let i = firstRow; i < lastRow; i++) {
            const tr = document.createElement('tr');
            
            // A. Row Header (Freeze Panes: Left)
            const rh = document.createElement('td');
            rh.textContent = i + 1;
            rh.style.minWidth = `${ROW_HEADER_WIDTH}px`;
            rh.style.backgroundColor = '#f8f9fa';
            rh.style.fontWeight = '600';
            rh.style.textAlign = 'center';
            rh.style.position = 'sticky';
            rh.style.left = '0';
            rh.style.zIndex = '10';
            rh.style.borderRight = '2px solid #dee2e6';
            tr.appendChild(rh);

            // B. Horizontal Spacer
            if (firstCol > 0) {
                const tdSpacer = document.createElement('td');
                tdSpacer.style.minWidth = `${firstCol * COL_WIDTH}px`;
                tdSpacer.style.padding = '0';
                tdSpacer.style.border = 'none';
                tr.appendChild(tdSpacer);
            }

            // C. Data Cells
            for (let j = firstCol; j < lastCol; j++) {
                const td = document.createElement('td');
                const id = indicesToCellId(i, j);
                td.id = id;
                td.classList.add('cell');
                if (id === selectedCellId) td.classList.add('selected');
                
                // Data & Styling
                const data = sheetData[id];
                const value = data ? data.value : '';
                td.textContent = value !== undefined ? value : '';
                
                if (typeof value === 'string' && value.startsWith('#')) td.classList.add('cell-error');
                if (data && data.style) Object.assign(td.style, data.style);

                tr.appendChild(td);
            }
            frag.appendChild(tr);
        }

        spreadsheet.appendChild(frag);
    }

    // --- LOGIC & FORMULAS ---
    function adjustFormulas(type, insertIndex, amount) {
        Object.keys(sheetData).forEach(id => {
            const data = sheetData[id];
            if (data && data.formula) {
                data.formula = data.formula.replace(/\b([A-Z]+[0-9]+)(:[A-Z]+[0-9]+)?\b/g, (match, startRef, rangePart) => {
                    const endRef = rangePart ? rangePart.substring(1) : null;
                    const updateRef = (ref) => {
                        const indices = cellIdToIndices(ref);
                        if (!indices) return ref;
                        if (type === 'row' && indices.row >= insertIndex) indices.row += amount;
                        else if (type === 'col' && indices.col >= insertIndex) indices.col += amount;
                        return indicesToCellId(indices.row, indices.col);
                    };
                    const newStartRef = updateRef(startRef);
                    return endRef ? `${newStartRef}:${updateRef(endRef)}` : newStartRef;
                });
            }
        });
    }

    function addRow() {
        if (!selectedCellId) return;
        const { row: selectedRow } = cellIdToIndices(selectedCellId);
        const insertIndex = selectedRow + 1;
        numRows++;
        
        // Safe move
        const newSheetData = { ...sheetData };
        const sortedKeys = Object.keys(sheetData).filter(k => cellIdToIndices(k).row >= insertIndex)
            .sort((a,b) => cellIdToIndices(b).row - cellIdToIndices(a).row); // Sort descending

        sortedKeys.forEach(oldId => {
            const {row, col} = cellIdToIndices(oldId);
            const newId = indicesToCellId(row + 1, col);
            newSheetData[newId] = newSheetData[oldId];
            delete newSheetData[oldId];
        });
        sheetData = newSheetData;
        
        adjustFormulas('row', insertIndex, 1);
        buildDependencyGraph();
        recalculateSheet();
        saveToLocalStorage();
    }

    function addColumn() {
        if (!selectedCellId) return;
        const { col: selectedCol } = cellIdToIndices(selectedCellId);
        const insertIndex = selectedCol + 1;
        numCols++;
        
        const newSheetData = { ...sheetData };
        const sortedKeys = Object.keys(sheetData).filter(k => cellIdToIndices(k).col >= insertIndex)
            .sort((a,b) => cellIdToIndices(b).col - cellIdToIndices(a).col);

        sortedKeys.forEach(oldId => {
            const {row, col} = cellIdToIndices(oldId);
            const newId = indicesToCellId(row, col + 1);
            newSheetData[newId] = newSheetData[oldId];
            delete newSheetData[oldId];
        });
        sheetData = newSheetData;

        adjustFormulas('col', insertIndex, 1);
        columnHeaders.splice(insertIndex, 0, undefined);
        buildDependencyGraph();
        recalculateSheet();
        saveToLocalStorage();
    }

    // --- DEPENDENCIES ---
    function updateDependencies(id, formula) {
        (dependencies[id] || []).forEach(depId => {
            dependents[depId] = (dependents[depId] || []).filter(d => d !== id);
        });
        dependencies[id] = [];
        if (formula && formula.startsWith('=')) {
            const cellRefs = formula.match(/[A-Z]+[0-9]+/gi) || [];
            const uniqueRefs = [...new Set(cellRefs.map(ref => ref.toUpperCase()))];
            dependencies[id] = uniqueRefs;
            uniqueRefs.forEach(refId => {
                if (!dependents[refId]) dependents[refId] = [];
                if (!dependents[refId].includes(id)) dependents[refId].push(id);
            });
        }
    }

    function buildDependencyGraph() {
        dependencies = {}; dependents = {};
        Object.keys(sheetData).forEach(id => {
            if (sheetData[id]?.formula) updateDependencies(id, sheetData[id].formula);
        });
    }

    // --- CALCULATOR ---
    const formulaFunctions = {
        SUM: args => args.flat().map(v => parseFloat(v)).filter(v => !isNaN(v)).reduce((a, b) => a + b, 0),
        AVERAGE: args => { const n = args.flat().map(parseFloat).filter(v => !isNaN(v)); return n.length ? n.reduce((a, b) => a + b, 0) / n.length : 0; },
        COUNT: args => args.flat().filter(v => v !== null && v !== '').length,
        MIN: args => Math.min(...args.flat().map(parseFloat).filter(v => !isNaN(v))),
        MAX: args => Math.max(...args.flat().map(parseFloat).filter(v => !isNaN(v))),
        PRODUCT: args => args.flat().map(v => parseFloat(v)).filter(v => !isNaN(v)).reduce((a, b) => a * b, 1),
        IF: (args) => {
             let cond; try { cond = new Function(`return ${args[0]}`)(); } catch(e) { cond = args[0]; }
             return (cond === true || cond === "true" || parseFloat(cond) > 0) ? args[1] : args[2];
        },
        CONCAT: args => args.flat().join(''),
        VLOOKUP: (args) => {
            const val = args[0], arr = args[1], col = parseInt(args[2]) - 1;
            if(!Array.isArray(arr)) return '#N/A';
            const row = arr.find(r => String(r[0]) === String(val));
            return row ? (row[col] ?? '') : '#N/A';
        }
    };

    function getCellValue(ref, visited) {
        if (!/^[A-Z]+[0-9]+$/i.test(ref)) return ref;
        const id = ref.toUpperCase();
        if (visited.has(id)) return '#REF!';
        visited.add(id);
        const data = sheetData[id];
        let val = data ? (data.formula ? evaluateFormula(data.formula, new Set(visited)) : data.value) : undefined;
        visited.delete(id);
        const num = parseFloat(val);
        return !isNaN(num) && String(val).trim() !== '' ? num : val;
    }

    function getRangeValues(startId, endId, visited) {
        const s = cellIdToIndices(startId);
        const e = cellIdToIndices(endId);
        if (!s || !e) return [];
        const vals = [];
        for (let r = Math.min(s.row, e.row); r <= Math.max(s.row, e.row); r++) {
            const row = [];
            for (let c = Math.min(s.col, e.col); c <= Math.max(s.col, e.col); c++) {
                row.push(getCellValue(indicesToCellId(r, c), visited));
            }
            vals.push(row);
        }
        return vals;
    }

    function evaluateFormula(formula, visited = new Set()) {
        try {
            if (!window.math) return "Loading...";
            let expr = formula.substring(1);
            const scope = {};
            const allRefs = expr.match(/[A-Z]+[0-9]+(:[A-Z]+[0-9]+)?/gi) || [];
            
            [...new Set(allRefs)].forEach(ref => {
                if (visited.has(ref)) throw new Error('#REF!');
                let val;
                if (ref.includes(':')) {
                    const [s, e] = ref.split(':');
                    val = getRangeValues(s, e, new Set(visited));
                } else {
                    val = getCellValue(ref, new Set(visited));
                }
                const scopeVar = ref.replace(':', '_');
                scope[scopeVar] = val;
                expr = expr.replaceAll(ref, scopeVar);
            });

            Object.keys(formulaFunctions).forEach(fn => {
                scope[fn] = (...args) => formulaFunctions[fn](args);
            });

            const result = math.evaluate(expr, scope);
            return result === Infinity ? '#DIV/0!' : result;
        } catch (e) { return '#ERROR!'; }
    }

    function recalculateSheet() {
        Object.keys(sheetData).forEach(id => {
            if (sheetData[id]?.formula) sheetData[id].value = evaluateFormula(sheetData[id].formula);
        });
        renderVisibleGrid();
    }

    function recalculate(startId) {
        const queue = [startId], visited = new Set([startId]);
        while (queue.length) {
            const curr = queue.shift();
            const data = sheetData[curr];
            if (data?.formula) data.value = evaluateFormula(data.formula);
            const cell = document.getElementById(curr);
            // Manually update DOM for this specific cell if visible, to avoid full re-render
            if (cell) {
                cell.textContent = data.value !== undefined ? data.value : '';
                if (String(data.value).startsWith('#')) cell.classList.add('cell-error');
                else cell.classList.remove('cell-error');
            }
            (dependents[curr] || []).forEach(d => {
                if (!visited.has(d)) { queue.push(d); visited.add(d); }
            });
        }
    }

    // --- INTERACTION ---
    function updateCell(id, input) {
        if (!id) return;
        if (!sheetData[id]) sheetData[id] = {};
        const data = sheetData[id];
        const oldFormula = data.formula;
        const isFormula = typeof input === 'string' && input.startsWith('=');
        
        if (isFormula) { data.formula = input; delete data.value; }
        else { delete data.formula; data.value = input; }
        
        if (oldFormula !== (isFormula ? input : null)) updateDependencies(id, isFormula ? input : null);
        recalculate(id);
        saveToLocalStorage();
    }

    function selectCell(cellOrId) {
        const newId = typeof cellOrId === 'string' ? cellOrId : cellOrId.id;
        if (!newId) return;
        
        if (selectedCellId) {
            const prev = document.getElementById(selectedCellId);
            if (prev) prev.classList.remove('selected');
        }
        selectedCellId = newId;
        
        // Auto-scroll logic
        const {row, col} = cellIdToIndices(newId);
        const top = row * ROW_HEIGHT;
        const left = col * COL_WIDTH;
        const {scrollTop, scrollLeft, clientHeight, clientWidth} = gridContainer;
        
        if (top < scrollTop) gridContainer.scrollTop = top;
        else if (top > scrollTop + clientHeight - ROW_HEIGHT) gridContainer.scrollTop = top - clientHeight + ROW_HEIGHT + HEADER_HEIGHT;
        
        if (left < scrollLeft) gridContainer.scrollLeft = left;
        else if (left > scrollLeft + clientWidth - COL_WIDTH) gridContainer.scrollLeft = left - clientWidth + COL_WIDTH + ROW_HEADER_WIDTH;

        renderVisibleGrid(); // Ensure visible
        
        const next = document.getElementById(newId);
        if(next) next.classList.add('selected');
        
        currentCellLabel.textContent = newId;
        const data = sheetData[newId];
        formulaInput.value = data ? (data.formula || data.value || '') : '';
    }

    function makeCellEditable(cell, clear) {
        if (!cell || cell.classList.contains('editing')) return;
        cell.classList.add('editing');
        cell.contentEditable = true;
        const data = sheetData[cell.id];
        cell.textContent = clear ? '' : (data ? (data.formula || data.value || '') : '');
        cell.focus();
        
        const finish = () => {
            cell.contentEditable = false;
            cell.classList.remove('editing');
            updateCell(cell.id, cell.textContent);
            selectCell(cell);
            cell.removeEventListener('blur', finish);
            cell.removeEventListener('keydown', onKey);
        };
        const onKey = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finish(); }
            if (e.key === 'Escape') { cell.textContent = data ? (data.value || '') : ''; finish(); }
        };
        cell.addEventListener('blur', finish);
        cell.addEventListener('keydown', onKey);
    }

    function handleFile(e) {
        const f = e.target.files[0];
        if(!f) return;
        if(!confirm("Overwrite current sheet?")) return;
        const r = new FileReader();
        r.onload = (evt) => {
            try {
                const wb = XLSX.read(new Uint8Array(evt.target.result), {type:'array'});
                const ws = wb.Sheets[wb.SheetNames[0]];
                const json = XLSX.utils.sheet_to_json(ws, {header:1});
                
                sheetData = {}; columnHeaders = []; dependencies = {}; dependents = {};
                numRows = Math.max(100, json.length + 20);
                numCols = Math.max(26, (json[0]?.length || 0) + 5);
                
                json.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if(val != null) {
                            const id = indicesToCellId(r, c);
                            sheetData[id] = {};
                            if(String(val).startsWith('=')) sheetData[id].formula = val;
                            else sheetData[id].value = val;
                        }
                    });
                });
                buildDependencyGraph();
                recalculateSheet();
                saveToLocalStorage();
                selectCell('A1');
            } catch(err) { alert("Error reading file"); console.error(err); }
        };
        r.readAsArrayBuffer(f);
        e.target.value = '';
    }

    function downloadCSV() {
        let maxR = -1, maxC = -1;
        Object.keys(sheetData).forEach(k => {
            const {row, col} = cellIdToIndices(k);
            if(row > maxR) maxR = row;
            if(col > maxC) maxC = col;
        });
        if(maxR === -1) return alert("Sheet empty");
        
        const rows = [];
        for(let r=0; r<=maxR; r++) {
            const row = [];
            for(let c=0; c<=maxC; c++) {
                const v = String(sheetData[indicesToCellId(r,c)]?.value ?? '');
                row.push(v.includes(',') ? `"${v}"` : v);
            }
            rows.push(row.join(','));
        }
        const blob = new Blob([rows.join('\n')], {type:'text/csv'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'sheet.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // --- NEW FEATURE: HTML TO XLSX CONVERTER LOGIC INTEGRATED ---
    function downloadXLSX() {
        // 1. Calculate Bounds
        let maxR = -1, maxC = -1;
        Object.keys(sheetData).forEach(k => {
            const {row, col} = cellIdToIndices(k);
            if(row > maxR) maxR = row;
            if(col > maxC) maxC = col;
        });
        if(maxR === -1) return alert("Sheet is empty");

        // 2. Construct Virtual HTML Table String
        // Note: We do NOT include the row headers (1, 2, 3) or column headers (A, B, C) 
        // unless custom column headers exist, as per instructions.
        
        let html = '<table><tbody>';
        
        // Check if custom headers exist
        const hasCustomHeaders = columnHeaders.some(h => h !== undefined);

        // Only add a header row if user has customized headers
        if (hasCustomHeaders) {
            html += '<tr>';
            for (let c = 0; c <= maxC; c++) {
                // Use custom name or empty string if strictly hiding default "A, B, C"
                let headerText = columnHeaders[c] || ""; 
                html += `<th>${headerText}</th>`;
            }
            html += '</tr>';
        }

        // Add Data Rows
        for(let r=0; r<=maxR; r++) {
            html += '<tr>';
            for(let c=0; c<=maxC; c++) {
                const id = indicesToCellId(r, c);
                const cell = sheetData[id];
                const value = cell ? (cell.value !== undefined ? cell.value : '') : '';
                
                // Convert JS styles to CSS string
                let styleStr = '';
                if (cell && cell.style) {
                    styleStr = Object.entries(cell.style)
                        .map(([k, v]) => `${k.replace(/[A-Z]/g, m => '-' + m.toLowerCase())}:${v}`)
                        .join(';');
                }
                
                html += `<td style="${styleStr}">${value}</td>`;
            }
            html += '</tr>';
        }
        html += '</tbody></table>';

        // 3. Parse HTML and Convert to Workbook
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const table = doc.querySelector('table');

            // Create SheetJS Workbook
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.table_to_sheet(table);
            XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

            // 4. Download
            XLSX.writeFile(wb, "spreadsheet.xlsx");
        } catch(e) {
            console.error(e);
            alert("Error converting to XLSX");
        }
    }

    // --- INIT ---
    document.addEventListener('DOMContentLoaded', () => {
        gridContainer = document.getElementById('grid-container');
        sizer = document.getElementById('sizer');
        spreadsheet = document.getElementById('spreadsheet');
        formulaInput = document.getElementById('formula-input');
        currentCellLabel = document.getElementById('current-cell-label');

        loadFromLocalStorage();
        buildDependencyGraph();
        recalculateSheet();
        selectCell('A1');

        // Event Listeners
        gridContainer.addEventListener('scroll', () => requestAnimationFrame(renderVisibleGrid));
        
        spreadsheet.addEventListener('click', e => {
            const cell = e.target.closest('.cell');
            if(cell) {
                if(cell.id !== selectedCellId) selectCell(cell);
                makeCellEditable(cell, false);
            }
        });
        
        spreadsheet.addEventListener('dblclick', e => {
            const th = e.target.closest('th[data-col]');
            if(th) {
                const col = parseInt(th.dataset.col);
                const old = th.textContent;
                th.contentEditable = true; th.focus();
                const end = () => {
                    th.contentEditable = false;
                    const val = th.textContent.trim();
                    if(val && val !== old) columnHeaders[col] = val;
                    else delete columnHeaders[col];
                    th.textContent = columnHeaders[col] || colIndexToLetter(col);
                    saveToLocalStorage();
                    th.removeEventListener('blur', end);
                };
                th.addEventListener('blur', end);
                th.addEventListener('keydown', e => { if(e.key === 'Enter') { e.preventDefault(); end(); }});
            }
        });

        formulaInput.addEventListener('change', e => updateCell(selectedCellId, e.target.value));
        formulaInput.addEventListener('keydown', e => { if(e.key==='Enter') { updateCell(selectedCellId, e.target.value); document.activeElement.blur(); }});

        window.addEventListener('keydown', e => {
            if(document.querySelector('.cell.editing')) return;
            if(!selectedCellId || (document.activeElement && !['BODY','TABLE','DIV'].includes(document.activeElement.tagName))) return;
            
            const {row, col} = cellIdToIndices(selectedCellId);
            if(e.key.length === 1 && !e.ctrlKey && !e.metaKey) { e.preventDefault(); makeCellEditable(document.getElementById(selectedCellId), true); }
            else if(e.key === 'F2' || e.key === 'Enter') { e.preventDefault(); makeCellEditable(document.getElementById(selectedCellId), false); }
            else if(e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); updateCell(selectedCellId, ''); }
            else if(e.key === 'ArrowUp') selectCell(indicesToCellId(Math.max(0, row-1), col));
            else if(e.key === 'ArrowDown') selectCell(indicesToCellId(Math.min(numRows-1, row+1), col));
            else if(e.key === 'ArrowLeft') selectCell(indicesToCellId(row, Math.max(0, col-1)));
            else if(e.key === 'ArrowRight') selectCell(indicesToCellId(row, Math.min(numCols-1, col+1)));
        });

        // Toolbar
        const click = (id, fn) => document.getElementById(id).onclick = fn;
        const apply = (s, v) => { 
            if(!selectedCellId) return; 
            sheetData[selectedCellId] = sheetData[selectedCellId] || {}; 
            sheetData[selectedCellId].style = sheetData[selectedCellId].style || {};
            sheetData[selectedCellId].style[s] = v;
            const cell = document.getElementById(selectedCellId);
            if(cell) Object.assign(cell.style, sheetData[selectedCellId].style);
            saveToLocalStorage();
        };

        click('bold-btn', () => apply('fontWeight', 'bold'));
        click('italic-btn', () => apply('fontStyle', 'italic'));
        click('underline-btn', () => apply('textDecoration', 'underline'));
        click('align-left-btn', () => apply('textAlign', 'left'));
        click('align-center-btn', () => apply('textAlign', 'center'));
        click('align-right-btn', () => apply('textAlign', 'right'));
        click('add-row-btn', addRow);
        click('add-col-btn', addColumn);
        click('clear-all-btn', () => { if(confirm("Clear all?")) { localStorage.removeItem(STORAGE_KEY); location.reload(); }});
        click('download-csv', downloadCSV);
        click('download-xlsx', downloadXLSX); // Updated Handler
        click('open-file-btn', () => document.getElementById('file-input').click());
        document.getElementById('file-input').onchange = handleFile;
        document.getElementById('font-color-picker').oninput = e => apply('color', e.target.value);
        document.getElementById('bg-color-picker').oninput = e => apply('backgroundColor', e.target.value);
    });
</script>
</body>
</html>
