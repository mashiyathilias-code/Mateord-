
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Rich Text Editor</title>
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Mammoth.js for .docx support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.21/mammoth.browser.min.js"></script>
    <!-- JSZip for .odt support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
    /* --- 1. CORE VARIABLES --- */
    :root {
        /* Light Mode: Pastel Blue to Pink */
        --bg-gradient: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
        --glass-surface: rgba(255, 255, 255, 0.25);
        --glass-border: rgba(255, 255, 255, 0.5);
        --glass-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        
        --text-color: #4a5568;
        --primary-color: #5a67d8; /* Darker blue for visibility */
        --accent-color: #d53f8c;
        
        /* Neumorphic Buttons */
        --btn-bg: rgba(255,255,255, 0.3);
        --btn-shadow: 
            3px 3px 6px rgba(0, 0, 0, 0.1), 
            -3px -3px 6px rgba(255, 255, 255, 0.8);
        
        /* Paper */
        --paper-bg: #ffffff;
        --paper-text: #000000;
        --paper-shadow: 0 20px 40px rgba(0,0,0,0.15);
    }

    [data-theme="dark"] {
        /* Dark Mode: Deep Blue/Cyan */
        --bg-gradient: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
        --glass-surface: rgba(0, 0, 0, 0.3);
        --glass-border: rgba(255, 255, 255, 0.1);
        --glass-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        
        --text-color: #e2e8f0;
        --primary-color: #00f2ff;
        --accent-color: #ff0080;
        
        /* Neumorphic Buttons Dark */
        --btn-bg: rgba(255, 255, 255, 0.05);
        --btn-shadow: 
            3px 3px 6px rgba(0, 0, 0, 0.5), 
            -3px -3px 6px rgba(255, 255, 255, 0.05);
        
        /* Paper */
        --paper-bg: #1e293b;
        --paper-text: #e2e8f0;
        --paper-shadow: 0 20px 40px rgba(0,0,0,0.6);
    }

    @keyframes drift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    /* Performance: Pause animation when tab is not visible */
    body.animations-paused {
        animation-play-state: paused;
    }

    /* --- 2. LAYOUT ENGINE (The Fix) --- */
    * { box-sizing: border-box; }

    body {
        font-family: 'Segoe UI', system-ui, sans-serif;
        margin: 0;
        height: 100vh; /* Full viewport height */
        display: flex;
        flex-direction: column; /* Stack Toolbar -> Editor -> Status */
        overflow: hidden; /* Prevent body scroll, handle inside containers */
        
        background: var(--bg-gradient);
        background-size: 300% 300%;
        animation: drift 5s ease infinite;
        color: var(--text-color);
        transition: color 0.3s ease;
    }

    /* --- 3. TOOLBAR (Fixed Header) --- */
    .toolbar {
        /* Layout: Rigid height, never shrinks */
        flex: 0 0 auto; 
        position: relative;
        z-index: 10;
        
        /* Glass Style */
        background: var(--glass-surface);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border-bottom: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
        
        padding: 10px 15px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
    }

    .tool-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0 10px;
        border-right: 1px solid var(--glass-border);
    }
    .tool-group:last-child { border-right: none; }

    .tool-icons { display: flex; gap: 8px; }
    
    .tool-group-label {
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        margin-top: 4px;
        opacity: 0.8;
    }

    /* --- 4. BUTTONS (Neumorphism) --- */
    button, .file-upload-btn, select {
        background: var(--btn-bg);
        border: 1px solid var(--glass-border);
        color: var(--text-color);
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: var(--btn-shadow);
        
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        outline: none;
    }

    button:hover, .file-upload-btn:hover {
        transform: translateY(-2px);
        background: rgba(255, 255, 255, 0.2);
        color: var(--primary-color);
    }

    button:active {
        transform: translateY(1px);
        box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
    }

    /* --- 5. EDITOR CONTAINER (Scrollable Area) --- */
    .editor-container {
        /* Layout: Fills remaining space */
        flex: 1 1 auto; 
        position: relative;
        overflow-y: auto; /* Scroll happens INSIDE here */
        padding: 40px 20px;
        
        display: flex;
        flex-direction: column;
        align-items: center;
        
        /* Custom Scrollbar */
        scrollbar-width: thin;
        scrollbar-color: var(--glass-border) transparent;
    }
    
    .editor-container::-webkit-scrollbar { width: 8px; }
    .editor-container::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 4px; }

    /* --- 6. THE PAPER (Content) --- */
    #content-area {
        background-color: var(--paper-bg);
        color: var(--paper-text);
        
        width: 21cm;
        min-height: 29.7cm;
        padding: 2.54cm; /* Standard Word margins */
        
        box-shadow: var(--paper-shadow);
        border-radius: 2px;
        outline: none;
        
        /* Typography */
        font-size: 12pt;
        line-height: 1.5;
        overflow-wrap: break-word;
        
        /* Prevent layout jumps */
        flex-shrink: 0;
        margin-bottom: 50px;
    }

    #content-area table { width: 100%; border-collapse: collapse; margin: 15px 0; border: 1px solid #ccc; }
    #content-area td, #content-area th { border: 1px solid #ccc; padding: 5px; }

    /* --- 7. STATUS BAR --- */
    .status-bar {
        flex: 0 0 auto; /* Rigid height */
        background: var(--glass-surface);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-top: 1px solid var(--glass-border);
        padding: 5px 20px;
        font-size: 12px;
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        z-index: 10;
    }

    #save-status { color: var(--primary-color); }
    #loader {
        display: none; position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8); color: white;
        padding: 15px 30px; border-radius: 8px; z-index: 9999;
    }
    
    /* Helper: Color Inputs */
    input[type="color"] { width: 30px; height: 30px; border: none; background: none; cursor: pointer; }
    
    /* Page Break Visual */
    .page-break-marker {
        border-top: 2px dashed var(--accent-color);
        margin: 20px 0; position: relative; opacity: 0.5;
    }
    .page-break-marker::after {
        content: "PAGE BREAK"; position: absolute; top: -10px; right: 0;
        font-size: 9px; background: var(--accent-color); color: white; padding: 2px 4px;
    }

    @media print {
        body { display: block; height: auto; background: white; overflow: visible; }
        .toolbar, .status-bar, #loader { display: none; }
        .editor-container { display: block; padding: 0; overflow: visible; height: auto; }
        #content-area { 
            box-shadow: none; width: 100%; margin: 0; padding: 0; 
            background: white !important; color: black !important; 
        }
    }
</style>
    
</head>
<body>

    <!-- Hidden File Input -->
    <input type="file" id="fileInput" accept=".docx, .txt, .odt" style="display: none;" onchange="handleFileSelect(this)">
    
    <!-- Loader -->
    <div id="loader"><i class="fas fa-spinner fa-spin"></i> Processing...</div>

    <!-- Toolbar -->
    <div class="toolbar">
        
        <!-- Group: FILE -->
     <!-- Group: FILE -->
<div class="tool-group">
    <div class="tool-icons">
        <label for="fileInput" class="file-upload-btn" title="Import File">
            <i class="fas fa-folder-open" style="color: var(--accent-color);"></i>
        </label>
        <button onclick="saveDoc('html')" title="Save HTML"><i class="fas fa-file-code" style="color: var(--primary-color);"></i></button>
        <button onclick="saveDoc('txt')" title="Download Text"><i class="fas fa-file-alt"></i></button>
        <!-- NEW BUTTON HERE -->
        <button onclick="saveDoc('odt')" title="Download ODT"><i class="fas fa-file-word" style="color: #2b5797;"></i></button>
        
        <button onclick="window.print()" title="Print"><i class="fas fa-print"></i></button>
        <button onclick="clearDoc()" title="Clear All" style="color: #d9534f;"><i class="fas fa-trash-alt"></i></button>
    </div>
    <span class="tool-group-label">File</span>
</div>

        <!-- Group: HISTORY -->
        <div class="tool-group">
            <div class="tool-icons">
                <button onclick="formatDoc('undo')" title="Undo"><i class="fas fa-undo"></i></button>
                <button onclick="formatDoc('redo')" title="Redo"><i class="fas fa-redo"></i></button>
            </div>
            <span class="tool-group-label">History</span>
        </div>

        <!-- Group: FONT -->
        <div class="tool-group">
            <div class="tool-icons">
                <select onchange="formatDoc('fontName', this.value)" title="Font Family">
                    <option value="Arial">Arial</option>
                    <option value="Calibri">Calibri</option>
                    <option value="Times New Roman">Times</option>
                    <option value="Segoe UI" selected>Segoe</option>
                    <option value="Verdana">Verdana</option>
                </select>
                <select onchange="formatDoc('fontSize', this.value)" title="Font Size" style="width:60px;">
                    <option value="1">Small</option>
                    <option value="3" selected>Norm</option>
                    <option value="5">Big</option>
                    <option value="7">Huge</option>
                </select>
                <div style="display:flex; gap:2px;">
                    <input type="color" oninput="formatDoc('foreColor', this.value)" title="Text Color">
                    <input type="color" oninput="formatDoc('hiliteColor', this.value)" value="#ffffff" title="Highlight">
                </div>
            </div>
            <span class="tool-group-label">Font</span>
        </div>

        <!-- Group: FORMAT -->
        <div class="tool-group">
            <div class="tool-icons">
                <button onclick="formatDoc('bold')" title="Bold"><i class="fas fa-bold"></i></button>
                <button onclick="formatDoc('italic')" title="Italic"><i class="fas fa-italic"></i></button>
                <button onclick="formatDoc('underline')" title="Underline"><i class="fas fa-underline"></i></button>
                <button onclick="formatDoc('strikeThrough')" title="Strikethrough"><i class="fas fa-strikethrough"></i></button>
                <button onclick="formatDoc('removeFormat')" title="Remove Styling"><i class="fas fa-eraser"></i></button>
            </div>
            <span class="tool-group-label">Styling</span>
        </div>

        <!-- Group: PARAGRAPH -->
        <div class="tool-group">
            <div class="tool-icons">
                <button onclick="formatDoc('justifyLeft')" title="Left"><i class="fas fa-align-left"></i></button>
                <button onclick="formatDoc('justifyCenter')" title="Center"><i class="fas fa-align-center"></i></button>
                <button onclick="formatDoc('justifyRight')" title="Right"><i class="fas fa-align-right"></i></button>
                <button onclick="formatDoc('insertUnorderedList')" title="Bullets"><i class="fas fa-list-ul"></i></button>
                <button onclick="formatDoc('insertOrderedList')" title="Numbers"><i class="fas fa-list-ol"></i></button>
            </div>
            <span class="tool-group-label">Paragraph</span>
        </div>

        <!-- Group: INSERT -->
        <div class="tool-group">
            <div class="tool-icons">
                <button onclick="insertPageBreak()" title="Page Break"><i class="fas fa-cut"></i></button>
                <button onclick="insertLink()" title="Link"><i class="fas fa-link"></i></button>
                <button onclick="insertImage()" title="Image"><i class="fas fa-image"></i></button>
                <button onclick="insertTable()" title="Table"><i class="fas fa-table"></i></button>
                <button onclick="formatDoc('insertHorizontalRule')" title="Line"><i class="fas fa-minus"></i></button>
            </div>
            <span class="tool-group-label">Page</span>
        </div>

        <!-- Group: VIEW -->
        <div class="tool-group">
            <div class="tool-icons">
                <button onclick="toggleTheme()" title="Toggle Dark Mode"><i class="fas fa-moon"></i></button>
            </div>
            <span class="tool-group-label">View</span>
        </div>
    </div>

    <!-- Editing Area -->
    <div class="editor-container">
        <div id="content-area" contenteditable="true" spellcheck="true"></div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div>
            <span class="status-item" id="save-status">Checking storage...</span>
        </div>
        <div>
            <span class="status-item">Words: <span id="word-count">0</span></span>
            <span class="status-item">Chars: <span id="char-count">0</span></span>
        </div>
    </div>

    <script>
    // --- 1. CONFIGURATION & STATE ---
    const DB_NAME = 'RichTextEditorDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'documents';
    const DOC_ID = 'currentDoc';
    let db;
    
    // Optimization: Dirty Flag System
    // We only save if 'isDirty' is true, and only once every few seconds.
    let isDirty = false;
    let saveInterval;
    
    const editor = document.getElementById('content-area');


    // --- 2. INDEXED DB (Storage) ---
    function initDB() {
        loadSavedTheme();
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = (event) => {
            console.error("Database error: " + event.target.errorCode);
            document.getElementById('save-status').innerText = "Offline Mode";
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            loadContentFromDB();
            // Start the optimized auto-saver
            startAutoSave();
        };
    }

    // --- 3. OPTIMIZED SAVE SYSTEM ---
    function startAutoSave() {
        // Check every 3 seconds. If changed, save.
        // This prevents the browser from freezing while typing fast in a large doc.
        saveInterval = setInterval(() => {
            if (isDirty) {
                saveContentToDB();
                isDirty = false;
            }
        }, 3000);
    }

    function saveContentToDB() {
        if (!db) return;
        
        // This line is expensive on 100k words, so we only do it when necessary
        const content = editor.innerHTML; 
        
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ id: DOC_ID, content: content, timestamp: new Date() });
        
        request.onsuccess = () => showSaveStatus("Saved");
        request.onerror = () => showSaveStatus("Error Saving");
    }

    function loadContentFromDB() {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(DOC_ID);

        request.onsuccess = (event) => {
            if (event.target.result && event.target.result.content) {
                if(editor.innerHTML.trim() === "" || editor.innerHTML === "<br>") {
                    editor.innerHTML = event.target.result.content;
                    updateStats();
                }
            }
            showSaveStatus("Ready");
        };
    }

    // --- 4. EDITOR LOGIC & KEYBOARD SHORTCUTS ---
    
    // Mark as dirty on input, update stats cheaply
    editor.addEventListener('input', () => {
        isDirty = true;
        showSaveStatus("Unsaved changes...");
        // Debounce stat updates slightly to help performance
        clearTimeout(window.statTimeout);
        window.statTimeout = setTimeout(updateStats, 500);
    });

    // Handle Keyboard Shortcuts (Ctrl+Z, Tab)
    editor.addEventListener('keydown', (e) => {
        // CTRL+Z (Undo)
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {

            e.preventDefault();
            document.execCommand('undo');
        }
        // CTRL+Y or CTRL+SHIFT+Z (Redo)
        if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
            e.preventDefault();
            document.execCommand('redo');
        }
        // TAB key (Insert indentation instead of losing focus)
        if (e.key === 'Tab') {
            e.preventDefault();
            document.execCommand('insertHTML', false, '&emsp;');
        }
    });

    function formatDoc(cmd, value = null) {
        if(value) {
            document.execCommand(cmd, false, value);
        } else {
            document.execCommand(cmd);
        }
        editor.focus();
        isDirty = true; // Formatting changes require a save
    }

    // --- 5. UI HELPERS ---
    function updateStats() {
        // On 100k words, innerText is heavy. We guard it.
        const text = editor.innerText || "";
        const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
        const charCount = text.length;
        document.getElementById('word-count').innerText = wordCount;
        document.getElementById('char-count').innerText = charCount;
    }

    function showSaveStatus(msg) {
        const status = document.getElementById('save-status');
        status.innerText = msg;
        status.style.opacity = 1;
    }

    function toggleTheme() {
        const body = document.body;
        if (body.getAttribute('data-theme') === 'dark') {
            body.removeAttribute('data-theme');
            localStorage.setItem('theme', 'light');
        } else {
            body.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
        }
    }

    function loadSavedTheme() {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') document.body.setAttribute('data-theme', 'dark');
    }

    function clearDoc() {
        if(confirm("Clear entire document?")) {
            editor.innerHTML = "";
            updateStats();
            isDirty = true; // Will trigger auto-save shortly
            editor.focus();
        }
    }

    // --- 6. FILE IMPORT/EXPORT WRAPPERS ---
    function handleFileSelect(input) {
        const file = input.files[0];
        if (!file) return;

        const loader = document.getElementById('loader');
        loader.style.display = 'block';
        const fileName = file.name.toLowerCase();

        if (fileName.endsWith('.docx')) {
            importDocx(file);
        } else if (fileName.endsWith('.txt')) {
            importTxt(file);
        } else if (fileName.endsWith('.odt')) {
            importOdt(file);
        } else {
            alert('Unsupported file format.');
            loader.style.display = 'none';
        }
        input.value = '';
    }

   function importTxt(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            // Split by newlines
            const lines = text.split(/\r?\n/);
            let htmlOutput = "";
            
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed) {
                    // Wrap actual text in Paragraph tags
                    htmlOutput += `<p>${line}</p>`;
                } else {
                    // Handle empty lines as empty paragraphs (visual spacing)
                    htmlOutput += `<p><br></p>`;
                }
            });
            
            editor.innerHTML = htmlOutput;
            postImportCleanup();
        };
        reader.readAsText(file);
    }

    function importDocx(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            mammoth.convertToHtml({arrayBuffer: e.target.result})
            .then(result => {
                editor.innerHTML = result.value;
                postImportCleanup();
            })
            .catch(err => {
                alert('Error reading DOCX.');

                document.getElementById('loader').style.display = 'none';
            });
        };
        reader.readAsArrayBuffer(file);
    }

    function importOdt(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            JSZip.loadAsync(e.target.result).then(function(zip) {
                return zip.file("content.xml").async("string");
            }).then(function(xmlContent) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
                const paragraphs = xmlDoc.getElementsByTagName("text:p");
                let htmlOutput = "";
                // Very basic ODT import loop
                for (let i = 0; i < paragraphs.length; i++) {
                    htmlOutput += `<p>${paragraphs[i].textContent}</p>`;
                }
                editor.innerHTML = htmlOutput;
                postImportCleanup();
            }).catch(function(err) {
                alert("Error reading ODT.");
                document.getElementById('loader').style.display = 'none';
            });
        };
        reader.readAsArrayBuffer(file);
    }

    function postImportCleanup() {
        document.getElementById('loader').style.display = 'none';
        isDirty = true; // Force save on next tick
        updateStats();
    }

    // --- COPY THE SAVE/ODT FUNCTIONS BELOW THIS LINE ---
    function saveDoc(type) {
        // ... (Paste your saveDoc function here)
         const content = editor.innerHTML;
        let blob;

        if (type === 'html') {
            blob = new Blob([`<html><body style='font-family:Arial;'>${content}</body></html>`], { type: 'text/html' });
            triggerDownload(blob, 'document.html');
        } 
        else if (type === 'txt') {
            blob = new Blob([editor.innerText], { type: 'text/plain' });
            triggerDownload(blob, 'document.txt');
        } 
        else if (type === 'odt') {
            exportODT();
        }
    }

    function triggerDownload(blob, filename) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        setTimeout(() => URL.revokeObjectURL(link.href), 100);
    }
    
    // --- Page Break Helper ---
    function insertPageBreak() {
        const html = `<div class="page-break-marker">&nbsp;</div>`;
        document.execCommand('insertHTML', false, html);
        editor.focus();
    }
    
    function insertLink() {
        const url = prompt("Enter the URL:");
        if (url) formatDoc('createLink', url);
    }

    function insertImage() {
        const url = prompt("Enter Image URL:");
        if (url) formatDoc('insertImage', url);
    }

    function insertTable() {
        const html = `
            <table style="width:100%; border-collapse: collapse;">
                <tr><td>Header 1</td><td>Header 2</td></tr>
                <tr><td>Data 1</td><td>Data 2</td></tr>
            </table><br>`;
        document.execCommand('insertHTML', false, html);
    }


function exportODT() {
    if (typeof JSZip === 'undefined') {
        alert("JSZip library not found. Cannot export.");
        return;
    }

    const loader = document.getElementById('loader');
    if(loader) loader.style.display = 'block';

    // Small timeout to allow UI to update before heavy lifting
    setTimeout(() => {
        try {
            generateODT();
        } catch (e) {
            console.error(e);
            alert("Export failed: " + e.message);
            if(loader) loader.style.display = 'none';
        }
    }, 50);
}

function generateODT() {
    const zip = new JSZip();
    const editor = document.getElementById('content-area');

    // -- 1. STATE & STYLES --
    let automaticStyles = [];
    let styleCounter = 0;
    const styleMap = new Map();
    let imageCounter = 0;
    const folderPictures = zip.folder("Pictures");

    // Standard ODT List Styles
    const listStyles = `
    <text:list-style style:name="ListBullet">
        <text:list-level-style-bullet text:level="1" text:bullet-char="â€¢">
            <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
                <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.27cm" fo:text-indent="-0.635cm" fo:margin-left="1.27cm"/>
            </style:list-level-properties>
        </text:list-level-style-bullet>
    </text:list-style>
    <text:list-style style:name="ListNumber">
        <text:list-level-style-number text:level="1" style:num-format="1">
            <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
                <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.27cm" fo:text-indent="-0.635cm" fo:margin-left="1.27cm"/>
            </style:list-level-properties>
        </text:list-level-style-number>
    </text:list-style>`;

    // -- 2. HELPERS --
    function escapeXML(str) {
        if (!str) return "";
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&apos;');
    }

    function rgbToHex(rgb) {
        if (!rgb || rgb === 'transparent' || rgb === 'inherit') return null;
        if (rgb.startsWith('#')) return rgb;
        const result = rgb.match(/\d+/g);
        if (!result || result.length < 3) return null;
        return "#" + ((1 << 24) + (parseInt(result[0]) << 16) + (parseInt(result[1]) << 8) + parseInt(result[2])).toString(16).slice(1);
    }

    function getStyleName(node, type) {
        const css = window.getComputedStyle(node);
        let props = "";

        // Paragraph Properties
        if (type === 'paragraph') {
            const alignMap = { 'left': 'start', 'right': 'end', 'center': 'center', 'justify': 'justify' };
            const alignRaw = node.style.textAlign || css.textAlign;
            if (alignRaw && alignMap[alignRaw]) {
                props += `fo:text-align="${alignMap[alignRaw]}" style:justify-single-word="false" `;
            }
            // Default margin to prevent crushing
            props += `fo:margin-top="0cm" fo:margin-bottom="0.2cm" `;
        } 
        // Text Properties
        else if (type === 'text') {
            const color = node.style.color || css.color;
            if (color && color !== 'rgb(0, 0, 0)') { // Skip default black to save space
                const hex = rgbToHex(color);
                if (hex) props += `fo:color="${hex}" `;
            }
            
            const bg = node.style.backgroundColor || css.backgroundColor;
            if (bg && bg !== 'rgba(0, 0, 0, 0)' && bg !== 'transparent') {
                const hex = rgbToHex(bg);
                if (hex) props += `fo:background-color="${hex}" `;
            }

            const font = node.style.fontFamily || css.fontFamily;
            if (font) {
                const cleanFont = font.replace(/['"]/g, '').split(',')[0].trim();
                props += `style:font-name="${cleanFont}" style:font-name-complex="${cleanFont}" `;
            }

            const size = node.style.fontSize || css.fontSize;
            if (size) {
                 // Simple mapping or pass-through
                 props += `fo:font-size="${size}" style:font-size-asian="${size}" `;
            }

            // Bold/Italic/Underline
            if (css.fontWeight === 'bold' || parseInt(css.fontWeight) >= 700) props += `fo:font-weight="bold" style:font-weight-asian="bold" `;
            if (css.fontStyle === 'italic') props += `fo:font-style="italic" style:font-style-asian="italic" `;
            if (css.textDecorationLine.includes('underline')) props += `style:text-underline-style="solid" style:text-underline-width="auto" `;
            if (css.textDecorationLine.includes('line-through')) props += `style:text-line-through-style="solid" `;
        }

        if (props.trim() === "") return null;

        const key = type + "|" + props;
        if (styleMap.has(key)) return styleMap.get(key);

        const name = (type === 'paragraph' ? "P" : "T") + (++styleCounter);
        const family = type === 'paragraph' ? 'paragraph' : 'text';
        
        automaticStyles.push(`<style:style style:name="${name}" style:family="${family}">
            <style:${type}-properties ${props} />
        </style:style>`);
        
        styleMap.set(key, name);
        return name;
    }

    // -- 3. PARSING LOGIC (The Fix) --

    function parseInline(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            return escapeXML(node.textContent);
        }
        if (node.nodeType !== Node.ELEMENT_NODE) return "";

        const tagName = node.tagName.toLowerCase();

        // Images (Inline)
        if (tagName === 'img') {
             // ... Image logic ...
             const src = node.getAttribute('src');
             if (src && src.startsWith('data:image')) {
                 try {
                     const ext = src.substring(src.indexOf('/') + 1, src.indexOf(';'));
                     const base64Data = src.split(',')[1];
                     const fileName = `image_${++imageCounter}.${ext}`;
                     folderPictures.file(fileName, base64Data, {base64: true});
                     let w = node.width ? node.width + "px" : "5cm";
                     let h = node.height ? node.height + "px" : "5cm";
                     return `<draw:frame draw:name="img${imageCounter}" text:anchor-type="as-char" svg:width="${w}" svg:height="${h}" draw:z-index="0"><draw:image xlink:href="Pictures/${fileName}" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></draw:frame>`;
                 } catch(e) { return ""; }
             }
             return "";
        }
        
        // Break
        if (tagName === 'br') return `<text:line-break/>`;

        // Formatting
        let content = Array.from(node.childNodes).map(parseInline).join('');
        const inlineTags = ['b', 'strong', 'i', 'em', 'u', 'span', 'font', 's', 'strike', 'a'];
        
        if (inlineTags.includes(tagName)) {
            const styleName = getStyleName(node, 'text');
            if (styleName) {
                return `<text:span text:style-name="${styleName}">${content}</text:span>`;
            }
        }
        return content;
    }

    // Identifies elements that MUST start a new ODT block
    function isBlock(node) {
        if (node.nodeType !== Node.ELEMENT_NODE) return false;
        const tag = node.tagName.toLowerCase();
        return ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'table', 'blockquote', 'pre', 'hr'].includes(tag) 
               || node.classList.contains('page-break-marker');
    }

    // This function handles the "Mixed Content" problem (text nodes next to divs)
    function processBlockChildren(parentNode) {
        let output = "";
        let inlineAccumulator = [];

        function flushAccumulator() {
            if (inlineAccumulator.length === 0) return;
            // We have loose text/inline elements. Wrap them in a Paragraph.
            // We can try to grab the style of the parent if it's a DIV acting as wrapper
            // But usually a generic paragraph is safest.
            const textContent = inlineAccumulator.map(n => parseInline(n)).join('');
            if(textContent.trim() !== "") { // Don't create empty paragraphs for whitespace
                output += `<text:p>${textContent}</text:p>`;
            }
            inlineAccumulator = [];
        }

        Array.from(parentNode.childNodes).forEach(child => {
            if (isBlock(child)) {
                flushAccumulator(); // Close previous text paragraph
                output += parseBlock(child); // Recurse into block
            } else {
                inlineAccumulator.push(child);
            }
        });
        flushAccumulator(); // Flush remaining text
        return output;
    }

    function parseBlock(node) {
        if (!node) return "";
        const tagName = node.tagName.toLowerCase();

        // 1. Lists
        if (tagName === 'ul' || tagName === 'ol') {
            const style = tagName === 'ul' ? 'ListBullet' : 'ListNumber';
            let listItems = "";
            Array.from(node.children).forEach(li => {
                if (li.tagName.toLowerCase() === 'li') {
                    // List items must contain a paragraph
                    let content = processBlockChildren(li);
                    // If processBlockChildren returned raw text (empty accumulator), it might be empty
                    // but usually it wraps in <text:p>.
                    // However, if the LI contains text directly, processBlockChildren wraps it.
                    // If LI contains a P, processBlockChildren returns the P.
                    if(!content) content = `<text:p/>`;
                    listItems += `<text:list-item>${content}</text:list-item>`;
                }
            });
            return `<text:list text:style-name="${style}">${listItems}</text:list>`;
        }

        // 2. Tables
        if (tagName === 'table') {
            let rows = "";
            const processCells = (row) => {
                let rOut = "";
                Array.from(row.children).forEach(cell => {
                     if(['td','th'].includes(cell.tagName.toLowerCase())) {
                         rOut += `<table:table-cell><text:p>${Array.from(cell.childNodes).map(parseInline).join('')}</text:p></table:table-cell>`;
                     }
                });
                return `<table:table-row>${rOut}</table:table-row>`;
            };
            
            // Handle thead/tbody or direct tr
            Array.from(node.children).forEach(child => {
                if(child.tagName.toLowerCase() === 'tr') rows += processCells(child);
                if(['thead','tbody'].includes(child.tagName.toLowerCase())) {
                     Array.from(child.children).forEach(tr => rows += processCells(tr));
                }
            });
            return `<table:table table:name="Tab${Date.now()}"><table:table-column table:number-columns-repeated="10"/>${rows}</table:table>`;
        }

        // 3. Headers
        if (tagName.startsWith('h') && tagName.length === 2) {
            const level = tagName.charAt(1);
            return `<text:h text:outline-level="${level}">${parseInline(node)}</text:h>`;
        }

        // 4. Page Break
        if (node.classList.contains('page-break-marker')) {
            return `<text:p text:style-name="PageBreak"/>`;
        }

        // 5. Paragraphs
        if (tagName === 'p') {
            const styleName = getStyleName(node, 'paragraph');
            const styleAttr = styleName ? `text:style-name="${styleName}"` : "";
            return `<text:p ${styleAttr}>${parseInline(node)}</text:p>`;
        }

        // 6. DIVs and other containers
        // This is the crucial fix for nested divs.
        // If a div contains block elements, we "unwrap" it and process children.
        // If it only contains text, we treat it as a paragraph.
        const hasBlockChildren = Array.from(node.children).some(c => isBlock(c));
        
        if (hasBlockChildren) {
            // Recursive "Unwrap"
            return processBlockChildren(node);
        } else {
            // Treat as Paragraph
            const styleName = getStyleName(node, 'paragraph');
            const styleAttr = styleName ? `text:style-name="${styleName}"` : "";
            return `<text:p ${styleAttr}>${parseInline(node)}</text:p>`;
        }
    }

    // -- 4. EXECUTION --
    
    // File 1: mimetype
    zip.file("mimetype", "application/vnd.oasis.opendocument.text", { compression: "STORE" });

    // File 2: Content Body
    // We treat the editor root as a Container Block
    const bodyContent = processBlockChildren(editor);

    // File 3: manifest.xml
    let manifestXML = `<?xml version="1.0" encoding="UTF-8"?>
<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
 <manifest:file-entry manifest:full-path="/" manifest:media-type="application/vnd.oasis.opendocument.text"/>
 <manifest:file-entry manifest:full-path="content.xml" manifest:media-type="text/xml"/>`;
    if (imageCounter > 0) {
        manifestXML += `<manifest:file-entry manifest:full-path="Pictures/" manifest:media-type="application/vnd.oasis.opendocument.image"/>`;
    }
    manifestXML += `</manifest:manifest>`;
    zip.folder("META-INF").file("manifest.xml", manifestXML);

    // File 4: content.xml
    const contentXML = `<?xml version="1.0" encoding="UTF-8"?>
<office:document-content 
    xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" 
    xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" 
    xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" 
    xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" 
    xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" 
    xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" 
    xmlns:xlink="http://www.w3.org/1999/xlink" 
    xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" 
    office:version="1.2">
  
  <office:automatic-styles>
    ${listStyles}
    ${automaticStyles.join('')}
    <style:style style:name="PageBreak" style:family="paragraph">
        <style:paragraph-properties fo:break-before="page"/>
    </style:style>
  </office:automatic-styles>
  
  <office:body>
    <office:text>
      ${bodyContent}
    </office:text>
  </office:body>
</office:document-content>`;

    zip.file("content.xml", contentXML);

    // Download
    zip.generateAsync({type:"blob", compression: "DEFLATE"}).then(function(blob) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = "document.odt";
        link.click();
        setTimeout(() => { 
            URL.revokeObjectURL(link.href);
            const loader = document.getElementById('loader');
            if(loader) loader.style.display = 'none';
        }, 100);
    }, function(err) {
        alert("Export Error: " + err);
    });
}

    // --- 7. INITIALIZATION (Restore this part) ---
    window.addEventListener('DOMContentLoaded', initDB);
    
    // Save one last time when closing the tab
    window.onbeforeunload = function() { 
        if(isDirty) saveContentToDB(); 
    };
</script>
<script src="shared/performance.js"></script>
    
</body>
</html>
